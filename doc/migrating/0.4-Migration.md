# dgrid 0.4 Migration Guide

dgrid 0.4 [incorporates significant changes](https://github.com/SitePen/dgrid/releases/tag/v0.4.0)
designed to make dgrid more reliable and easier to extend. Some changes will require updates
to code written for dgrid 0.3.  This document explains the major changes in more detail, with examples
contrasting 0.3 and 0.4 API usage.

This document discusses the following changes:

* Dojo version support (1.8+)
* Replacing dojo/store with dstore
* Using the mixins which were converted from column plugins:
	* editor
	* selector
	* tree
* Proper use of `List#renderArray`

## Dojo version support

As a reminder, dgrid 0.4 no longer supports Dojo 1.7.  dstore requires Dojo 1.8 or newer (primarily for
`dojo/request` and the new Deferred and Promise implementation), so dgrid 0.4 requires it as well.

Upgrading from Dojo 1.7 to 1.8 or newer should be relatively painless, as 1.x releases are intended to be
backwards-compatible.  See Dojo's [release notes](http://dojotoolkit.org/reference-guide/releasenotes/) for
further information.

## Replacing dojo/store with dstore

dgrid 0.4 interacts with [dstore](https://github.com/SitePen/dstore), and no longer directly supports the
`dojo/store` API.

dstore's API contains familiar methods for manipulating individual items like
`get`, `put` and `remove`. The primary difference with dojo/store lies in the querying API,
provided by [`dstore/Collection`](https://github.com/SitePen/dstore/blob/master/docs/Collection.md).

Ideally, stores should be refactored to use the dstore API.  However, dstore also provides the
[StoreAdapter](https://github.com/SitePen/dstore/blob/master/docs/Adapters.md#storeadapter) module to bridge the
dojo/store and dstore APIs.

```js
var dstoreStore = new StoreAdapter({ objectStore: dojoStore });
```

### dgrid APIs interacting with dstore

#### dgrid 0.3

In dgrid 0.3 and earlier, stores were passed to store-based grids via the `store` property:

```js
require([
	'dojo/store/Memory', 'dgrid/OnDemandGrid'
]), function (Memory, OnDemandGrid) {
	var data = [ /* Populate data with items... */ ];

	// Create a store object.
	var store = new Memory({ data: data });

	// Create a grid referencing the store.
	var grid = new OnDemandGrid({
		store: store,
		columns: { /* Define columns... */ }
	}, 'grid');
}
```

Filtering was performed by setting the `query` property:

```js
// Create a grid referencing the store.
var grid = new OnDemandGrid({
	store: store,
	query: { size: 'large'; } // Show large items only.
	columns: { /* Define columns... */ }
}, 'grid');
```

#### dgrid 0.4

In dgrid 0.4, the `store` and `query` properties have been replaced by the `collection` property.
The `collection` property expects an object implementing the `dstore/Collection` API.
Since `dstore/Store` extends `dstore/Collection`, you may set a grid's `collection` property to a either a store or a
collection (such as one which has been filtered).

```js
require([
	'dstore/Memory', 'dgrid/OnDemandGrid'
]), function (Memory, OnDemandGrid) {
	var data = [ /* Populate data with items... */ ];

	// Create a store object.
	var store = new Memory({ data: data });

	// Create a grid referencing the store.
	var grid = new OnDemandGrid({
		collection: store,
		columns: { /* Define columns... */ }
	}, 'grid');

	grid.startup();
}
```

When you want to filter the displayed items, first use dstore's `Collection` API to filter the items
and then assign the resulting collection to the grid's `collection` property:

```js
// Create a grid referencing filtered items from the store.
var grid = new OnDemandGrid({
	collection: store.filter({ size: 'large' }), // Show only the large items.
	columns: { /* Define columns... */ }
}, 'grid');
```

Note that since each `Collection` method returns a new `Collection` object, the method calls may be chained.

You can change a grid's store filter by reassigning the `collection` property. Here is an
example of displaying items in a grid based on the items' sizes when buttons are clicked.

```js
on(smallButtonNode, 'click', function () {
	// When the "small" button is clicked, display only the small items.
	grid.set('collection', store.filter({ size: 'small' });
});
on(mediumButtonNode, 'click', function () {
	// When the "medium" button is clicked, display only the medium items.
	grid.set('collection', store.filter({ size: 'medium' });
});
on(largeButtonNode, 'click', function () {
	// When the "large" button is clicked, display only the large items.
	grid.set('collection', store.filter({ size: 'large' });
});
```

Further information on using dstore with dgrid 0.4 is available in the updated
[Using Grids and Stores](http://dojofoundation.org/packages/dgrid/tutorials/0.4/grids_and_stores/) tutorial.

## Using mixins converted from column plugins

In dgrid 0.3 and earlier, several features were exposed as *column plugins*,
functions that decorate column definition objects. In dgrid 0.4, the
plugins were converted to mixins to make them easier to use and extend.

Each affected module is discussed below with examples.

### Editor

The Editor module is used to add an input field to one or more grid columns.

#### dgrid 0.3

In dgrid 0.3 and earlier, you would apply the `editor` column plugin to each
individual editable column, and could pass `editor` and `editOn`
either via the column definition object or via extra arguments:

```js
require([
	'dgrid/Grid', 'dgrid/editor'
]), function (Grid, editor) {
	var grid = new Grid({
		columns: [
			// Passing all editor properties in the column definition parameter:
			editor({
				field: 'firstName',
				label: 'First',
				editor: 'text',
				editOn: 'click'
			}),
			// Passing the editor properties as additional parameters:
			editor({
				field: 'lastName',
				label: 'Last'
			}, 'text', 'click'),
			// This column has no editors:
			{
				field: 'age',
				label: 'Age'
			},
			// This field always shows a text input:
			editor({
				field: 'income',
				label: 'Income'
			})
		]
	}, 'grid');
}
```

#### dgrid 0.4

In dgrid 0.4, you would incorporate the `Editor` mixin in your constructor, and specify the `editor`
property (and optionally others) on each editable column:

```js
require([
	'dojo/_base/declare', 'dgrid/Grid', 'dgrid/Editor'
]), function (declare, Grid, Editor) {
	// Create a custom grid by mixing in Editor
	var grid = new (declare([ Grid, Editor ]))({
		columns: [
			// These columns have the same effect as above,
			// but there is only one way to specify editor and editOn in 0.4:
			{
				field: 'firstName',
				label: 'First',
				editor: 'text',
				editOn: 'click'
			},
			{
				field: 'lastName',
				label: 'Last',
				editor: 'text',
				editOn: 'click'
			),
			// This column has no editors:
			{
				field: 'age',
				label: 'Age'
			},
			// This field always shows a text input:
			editor({
				field: 'income',
				label: 'Income',
				editor: 'text'
			})
		]
	}, 'grid');
}
```

Refer to the [`Editor` mixin documentation](../components/mixins/Editor.md)
for more information.

### Selector

The Selector module is used in conjunction with the Selection mixin to add a selector component to a grid column.
Clicking the selector component selects or deselects the entire row.

#### dgrid 0.3

In dgrid 0.3 and earlier, you would apply the `selector` column plugin to the desired column:

```js
require([
	'dojo/_base/declare', 'dgrid/OnDemandGrid', 'dgrid/Selection', 'dgrid/selector'
], function (declare, OnDemandGrid, Selection, selector) {
	var grid = new (declare([ OnDemandGrid, Selection ]))({
		store: store,
		selectionMode: 'single',
		columns: {
			col1: selector({ label: 'Select' }),
			col2: 'Column 2'
		}
	}, 'grid');
});
```

You could optionally pass a second argument to the plugin or include `selectorType` in the column definition's
properties to override the default checkbox selector:

```js
	// As second argument:
	col1: selector({ label: 'Select'}, 'radio'),

	// In column definition object:
	col1: selector({ label: 'Select', selectorType: 'radio' }),
```

#### dgrid 0.4

In dgrid 0.4, you would incorporate the `Selector` mixin in your constructor, and specify the `selector`
property on the desired column:

```js
require([
	'dojo/_base/declare', 'dgrid/Grid', 'dgrid/Selector', 'dstore/Memory'
], function (declare, Grid, Selector, Memory) {
	var store = new Memory({ data: [ /* ... */ ]});

	// In 0.4, Selector already inherits Selection so you don't have to
	var grid = new (declare([ Grid, Selector ]))({
		collection: store,
		columns: {
			col1: { label: 'Select', selector: 'checkbox' }),
			col2: 'Column 2'
		}
	}, 'grid');
});
```

Notice that the presence of the `selector` property indicates that the column should render selectors,
while also indicating the type of selector component to use.
This replaces the plugin invocation and the `selectorType` property from 0.3.

Refer to the [`Selector` documentation](../components/mixins/Selector.md)
for more information.

### Tree

The Tree module allows expanding rows to display children in a hierarchical store.

#### dgrid 0.3

In dgrid 0.3 and earlier, you would apply the `tree` plugin around the desired column:

```js
require([
	'dgrid/OnDemandGrid', 'dgrid/tree'
], function (OnDemandGrid, tree) {
	var store = ...;
	var treeGrid = new OnDemandGrid({
		store: store,
		columns: {
			name: tree({ label: 'Name' }),
			population: 'Population',
			timezone: 'Timezone'
		}
	}, 'treeGrid');
});
```

#### dgrid 0.4

With dgrid 0.4, combine the `Tree` mixin with `OnDemandGrid` or `Pagination`.

```js
require([
	'dojo/_base/declare', 'dgrid/OnDemandGrid', 'dgrid/Tree'
], function (declare, OnDemandGrid, Tree) {
	var store = ...;
	var treeGrid = new (declare([ OnDemandGrid, Tree ]))({
		collection: store,
		columns: {
			name: {
				label: 'Name',
				renderExpando: true
			},
			population: 'Population',
			timezone: 'Timezone'
		}
	}, 'treeGrid');
});
```

The `Tree` mixin will render the expando icon in the first column that contains the `renderExpando` property. The
value of `renderExpando` can also be a function that renders a custom expando icon or widget.

Also note that several of `Tree`'s configuration properties have been moved from the column definition to the
grid constructor options, as it is expected that there will be only one tree column:

* `collapseOnRefresh`
* `treeIndentWidth` (formerly `indentWidth`)
* `shouldExpand`
* `enableTreeTransitions` (formerly `enableTransitions`)

Refer to the [`Tree` mixin documentation](../components/mixins/Tree.md)
for more information.

## Proper use of renderArray

With dgrid 0.3 and earlier, you could call `store.query()` and pass the results directly to `List#renderArray` to
render all of the items returned by the store. In dgrid 0.4, `List#renderArray` only accepts standard arrays,
greatly simplifying the implementation.  Logic pertaining to query results is now located in
`_StoreMixin#renderQueryResults`.

If you want a list or grid that will display all of the items in a store without paging and without the full
implementation of `OnDemandList`, take a look at the
[Rendering All Store Data at Once](http://dojofoundation.org/packages/dgrid/tutorials/0.4/single_query/) tutorial.
It demonstrates how to extend 'dgrid/_StoreMixin' to create a lightweight mixin that fetches all items from a collection
when a list or grid is refreshed.

Another benefit of `renderArray` *only* handling arrays, synchronously, is that it greatly simplifies extensions.
Previously, properly extending `renderArray` would involve using `dojo/when` to wrap its return
value to ensure that code truly executes after the results resolve.  This is no longer necessary now that
`renderArray` is guaranteed to operate synchronously.
